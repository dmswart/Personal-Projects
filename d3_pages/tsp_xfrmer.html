<html>
<head>
    <script src='./dmslib_core.js'></script>
    <script src='./dmslib_point2d.js'></script>
    <script src='./tsp_tour_generation.js'></script>
    <script src='./tsp_tour_utilities.js'></script>
    <script src='http://d3js.org/d3.v3.min.js'></script>
</head>
<body>
    <div id='controls'>
        <label for='first_color'>1st Colour:</label> <input id='first_color' type='text' value='red' onchange='first_color=this.value;onColorChange();'>
        <label for='first_color_segments'>#:</label> <input id='first_color_segments' type='number' min='0' value='3' onchange='first_color_segments=this.value;updateLine();'>
        <label for='second_color'>2nd Colour:</label> <input id='second_color' type='text' value='black' onchange='second_color=this.value;onColorChange();'><br>
        <label for='requested_size'>Pts:</label> <input id='requested_size' type='number' value=200 onchange='requested_size=this.value;'>
        <label for='fps'>Frames per second:</label> <input id='fps' type='number' min='1' max=1000 value=16 onchange='fps=this.value;'> <br> <br>
        <button onclick='get_tour("random");'>random</button>
        <button onclick='get_tour("house");'>house</button>
        <button onclick='get_tour("circle");'>circle</button>
        <button onclick='get_tour("spiral");'>spiral</button><br>

        <input type='button' id='TSP' onclick='go("TSP")' value='TSP'/>
        <input type='button' id='Smooth' onclick='go("Smooth")' value='Smooth'/>
        <input type='button' id='TakeTour' onclick='go("TakeTour")' value='Take Tour'/>

        <input type='button' id='Animate' onclick='go("Animate")' value='Animate'/>
        <label for='sa_temp'>SA temp.:</label> <input id='sa_temp' type='number' min='0' max='100' value='30' onchange='sa_temp=this.value;'>
        <input type='button' id='OptimizeAnimation' onclick='go("OptimizeAnimation")' value='OptimizeAnimation'/> <br>
    </div>

    <div id='output'></div>
</body>
</html>


<script>
    var scale = 350,
        size = new DMSLib.Point2D(2*scale+580, 2*scale+20),
        center = size.div(2),
        first_color_segments = 3,
        first_color = 'red',
        second_color = 'black',
        line_thickness = 4,
        requested_size = 200,
        timer,
        sa_temp = 30,
        fps = 30;


    ///////////////////// D3 focused display routines.
    var svg = d3.select('#output').append('svg')
            .attr('width', size.x)
            .attr('height', size.y);

    var line_space = svg.append('g')
            .attr('transform', 'translate('+center.x+','+center.y+') scale('+scale+')');

    first_line = line_space.append('path')
            .attr('id', 'first_line')
            .attr('stroke', first_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');
    second_line = line_space.append('path')
            .attr('id', 'second_line')
            .attr('stroke', second_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');

    var lineFunction = d3.svg.line()
            .x(function(d) { return d.x;})
            .y(function(d) { return d.y;})
            .interpolate('linear');
            // .interpolate('basis');

    var updateLine = function(frame_time) {
        // split into first, second
        var first_line_pts = tour.slice(0,first_color_segments)
                                 .concat(tour[first_color_segments%tour.length]);
        var second_line_pts = tour.slice(first_color_segments,tour.length)
                                  .concat(tour[0]);

        if (frame_time===undefined) {
            first_line.attr('d', lineFunction(first_line_pts));
            second_line.attr('d', lineFunction(second_line_pts));
        } else {
            first_line
                    .transition()
                    .duration(frame_time)
                    .ease('linear')
                    .attr('d', lineFunction(first_line_pts));
            second_line
                    .transition()
                    .duration(frame_time)
                    .ease('linear')
                    .attr('d', lineFunction(second_line_pts));
        }
    };

    var onColorChange = function() {
        d3.select('#first_line').attr('stroke', first_color);
        d3.select('#second_line').attr('stroke', second_color);
    };


    ////////////////////////////////// Launching framework
    var go = function (method) {
        var method_fns = { "Smooth" : smooth,
                           "TSP" : tsp,
                           "Animate" : animate,
                           "TakeTour" : take_tour,
                           "OptimizeAnimation" : optimize_animation };
        var method_fn = method_fns[method];

        if (!timer) {
            d3.select('#' + method).property('value', 'Stop');
            method_fn();
        } else {
            clearTimeout(timer);
            timer = null;
            d3.select('#' + method).property('value', method);
        }
    };

    var get_tour = function(method) {
        var method_fns = {'circle' : get_circle_pts,
                          'spiral' : get_spiral_pts,
                          'house' : get_house_pts,
                          'random' : get_random_pts};
        var method_fn = method_fns[method];

        tour = method_fn(requested_size);
        normalize(tour);
        updateLine();
    };


    var is_valid_new_point = function(pts, new_pt, idx) {
        var a1 = pts[(idx - 1 + pts.length) % pts.length];
        var a2 = new_pt;
        var a3 = pts[(idx+1) % pts.length];

        for (var i = 0; i < pts.length; i++) {
            var b1 = pts[i];
            var b2 = pts[(i+1)%pts.length];

            // edge intersection
            if (b1 !== a1 && b1 !== a2) {
                if (edge_intersects_edge(a1, a2, b1, b2) || edge_intersects_edge(a2, a3, b1, b2)) {
                    return false;
                }
            }
        }
        return true;
    };

    var smooth = function(max_mvmt) {
        var mvmt = 0;

        // if max_mvt = undefined, it's first frame: start animation
        if (max_mvmt === undefined) {
            max_mvmt = 0;

            animation2 = animation;
            animation = [];
            var frame = copy_pts(tour);
            animation.push(frame);
        }

        var saved_tour = copy_pts(tour);

        var num_iter, idx, prev, next;
        for (num_iter = 0; num_iter < 2000; num_iter++) {
            new_tour = [];
            for (idx = 0; idx < tour.length; idx++) {
                prev = (idx - 1 + tour.length) % tour.length;
                next = (idx + 1) % tour.length;

                var new_pt;
                new_pt = tour[idx].add(tour[prev]).add(tour[next]).div(3);

                if (is_valid_new_point(tour, new_pt, idx)) {
                    new_tour[idx] = new_pt;
                } else {
                    new_tour[idx] = tour[idx];
                }
            }
            tour = new_tour;
            normalize(tour);

            mvmt = movement(tour, saved_tour);
            if(mvmt >= max_mvmt) { break; }
        }

        // if this is first time through, we use this amount of movement as the step amount.
        if (max_mvmt === 0) {max_mvmt = mvmt;}

        animation.push(copy_pts(tour));

        updateLine();

        if (mvmt < max_mvmt) {
            timer = null;
            d3.select('#Smooth').property('value', 'Smooth');
        } else {
            timer = setTimeout(function() {smooth(max_mvmt); }, 21);
        }
    };

    var tsp = function () {
        var changed = false;

        var a1, b1, a2, b2,
            a1toa2, b1tob2, a1tob1, a2tob2;
        for (a1 = 0; a1 < tour.length; a1++) {
            for (b1 = a1 + 2; b1 < tour.length; b1++) {
                a2 = (a1 + 1) % tour.length;
                b2 = (b1 + 1) % tour.length;

                a1toa2 = tour[a2].sub(tour[a1]).R();
                b1tob2 = tour[b2].sub(tour[b1]).R();
                a1tob1 = tour[b1].sub(tour[a1]).R();
                a2tob2 = tour[b2].sub(tour[a2]).R();

                if (a1tob1 + a2tob2 < a1toa2 + b1tob2) {
                    // swap [a2 ... b1]
                    var idx, from, to, tmp;
                    for (idx = 0; a2 + idx < b1 - idx; idx++) {
                        from = (a2 + idx) % tour.length;
                        to = (b1 - idx) % tour.length;
                        tmp = new DMSLib.Point2D(tour[from]);
                        tour[from] = new DMSLib.Point2D(tour[to]);
                        tour[to] = new DMSLib.Point2D(tmp);
                    }
                    changed = true;
                }
            }
        }

        if (!changed) {
            timer = null;
            d3.select('#TSP').property('value', 'TSP');
            if(animation.length) { tour = match_other(tour, animation[0]);}
            updateLine();
        } else {
            updateLine();
            timer = setTimeout(function() {tsp(); }, 21);
        }
    };


    var take_tour = function() {
        first_color_segments++;
        d3.select('#first_color_segments').property('value', first_color_segments);
        updateLine();

        if(first_color_segments < tour.length) {
            timer = setTimeout(function() {take_tour(); }, 1000/fps);
        } else {
            timer = null;
            d3.select('#TakeTour').property('value', 'Take Tour');
        }
    };

    var animate = function(frame) {
        if(frame === undefined) {
            frame = 0;
            tour = animation[0];
            updateLine();
            timer = setTimeout(function() {animate(frame+1); }, 2000);
        } else if(frame < animation.length + animation2.length) {
            if(frame < animation.length) {
                tour = animation[frame];
            } else {
                tour = animation2[animation2.length + animation.length - frame - 1]
            }
            updateLine(1000/fps);
            timer = setTimeout(function() {animate(frame+1); }, 1000/fps);
        } else {
            timer = null;
            d3.select('#Animate').property('value', 'Animate');
        }
    };

    var optimize_animation = function() {
        if(animation2.length) {
            animation = animation.concat(animation2.reverse());
            animation2 = [];
        }

        for(var f = 1; f < animation.length-1; f++) {
            var new_frame = [];
            for(var p = 0; p < animation[f].length; p++) {

                var prev = (p + animation[f].length - 1) % animation[f].length;
                var next = (p + 1) % animation[f].length;

                var newpt = animation[f][p]
                        .add(animation[f+1][p])
                        .add(animation[f-1][p])
                        .add(animation[f][prev].mul(0.05))
                        .add(animation[f][next].mul(0.05))
                        .div(3.1)
                        .add(DMSLib.Point2D.fromPolar(Math.random() * (DMSLib.TAU * 0.5 / animation[f].length) * (sa_temp / 100),
                                                      Math.random() * DMSLib.TAU));

                if( is_valid_new_point(animation[f], newpt, p)) {
                    new_frame.push(newpt);
                } else {
                    new_frame.push(animation[f][p]);
                }
            }
            animation[f] = new_frame;
        }

        tour = animation[Math.floor(animation.length/2)];
        updateLine();

        timer = setTimeout(function() {optimize_animation();}, 11);
    };

    /////////////////////////////// kick it off!
    var tour = [],
        animation = [],
        animation2 = [];

    get_tour('random');


    // TODO - make a tour class, an animation class, move animation to new file
    // TODO - 3d version: on a sphere.
    // TODO - read / write routes from/to file system
    // TODO - figure out why sometimes (crowded) points get stuck


</script>
