<html>
<head>
    <script src='./dmslib_core.js'></script>
    <script src='./dmslib_point2d.js'></script>
    <script src='http://d3js.org/d3.v3.min.js'></script>
    1st Colour: <input type='text' value='red' onchange='first_color=this.value;onColorChange();'>
    %:<input type='number' min='0' max='100' value='0' onchange='first_color_percentage=this.value;updateLine();'>
    2nd Colour: <input type='text' value='black' onchange='second_color=this.value;onColorChange();'><br>
    Pts: <input type='number' value=200 onchange='requested_pts=this.value;'> <br>
    <button onclick='pts=get_random_pts();normalize_pts();updateLine();'>random</button>
    <button onclick='pts=get_house();normalize_pts();updateLine();'>house</button>
    <button onclick='pts=get_E_pts();normalize_pts();updateLine();'>E</button>
    <button onclick='pts=get_spiral_pts(1);normalize_pts();updateLine();'>CW spiral</button>
    <button onclick='pts=get_spiral_pts(-1);normalize_pts();updateLine();'>CCW spiral</button> <br><br>

    <input type='button' id='TSP' onclick='go("TSP")' value='TSP'/>
    <input type='button' id='Smooth' onclick='go("Smooth")' value='Smooth'/>
    <input type='button' id='Animate' onclick='go("Animate")' value='Animate'/> <br>
</head>
<body>
<div id='output'></div>
</body>
</html>


<script>
    var scale = 350,
        size = new DMSLib.Point2D(2*scale+580, 2*scale+20),
        center = size.div(2),
        first_color_percentage = 0.0,
        first_color = 'red',
        second_color = 'black',
        line_thickness = 4,
        requested_pts = 200,
        timer;

    var get_E_pts = function() {
        var result = [];
        for(var i=-10; i<10; i+=4) {
            for(var j=-8; j<=10; j+=2) {result.push( new DMSLib.Point2D(j,i) );}
            for(var j=10; j>=-8; j-=2) {result.push( new DMSLib.Point2D(j,i+2) );}
        }
        for(var i=8; i>=-10; i-=1) {
            result.push( new DMSLib.Point2D(-10,i) );
        }

        return result;
    };

    var get_spiral_pts = function(turn) {
        var result = [];

        // way in
        for(i=0; i<=requested_pts/2; i++) {
            result.push( new DMSLib.Point2D.fromPolar((i+30) * turn, i/10) );
        }
        // way out
        for(i=requested_pts/2; i>=0; i--) {
            result.push( new DMSLib.Point2D.fromPolar((i+60) * turn, i/10) );
        }

        return result;
    };

    var get_random_pts = function() {
        result = [];
        for(var i=0; i<requested_pts; i++) {
            result.push( new DMSLib.Point2D(Math.random() - 0.5, Math.random() - 0.5).mul(2) );
        }
        return result;
    };

    var get_house = function() {
        result = [];
        house_pts.forEach(function(pt) {
            result.push( new DMSLib.Point2D(pt.x, pt.y));
        });
        return result;
    };

    var calc_centroid = function(pts) {
        result = new DMSLib.Point2D();
        pts.forEach( function(pt) {
            result = result.add(pt); 
        });
        return result.div(pts.length); 
    }; 

    var avg_R = function(pts) {
        var total = 0;
        pts.forEach( function(pt) {
            total += pt.R();
        });
        return total / pts.length;
    }; 

    var curve_length = function(pts) {
        result = 0;
        for(var i=0; i<pts.length-1; i++) {
           result += pts[i].sub(pts[i+1]).R();
        }
        return result;
    };



    var svg = d3.select('#output').append('svg')
            .attr('width', size.x)
            .attr('height', size.y);

    var line_space = svg.append('g')
            .attr('transform', 'translate('+center.x+','+center.y+') scale('+scale+')');

    first_line = line_space.append('path')
            .attr('id', 'first_line')
            .attr('stroke', first_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');
    second_line = line_space.append('path')
            .attr('id', 'second_line')
            .attr('stroke', second_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');

    var lineFunction = d3.svg.line()
            .x(function(d) { return d.x;})
            .y(function(d) { return d.y;})
            .interpolate('linear');

    var updateLine = function(transition = 0) {
        // split first, second
        var split = Math.floor(pts.length * first_color_percentage / 100.0);
        var second_line_pts = pts.slice(split,pts.length);
        second_line_pts.push(pts[0]);

        first_line
            .transition()
            .duration(transition)
            .attr('d', lineFunction(pts.slice(0,split+1)));
        second_line
            .transition()
            .duration(transition)
            .attr('d', lineFunction(second_line_pts));

        /* updateSelection = line_space.selectAll(".dot").data(pts);
        updateSelection
            .attr("r", (line_thickness/2+1) / scale)
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
        updateSelection
          .enter().append("circle")
            .attr("class", "dot")
            .attr("r", (line_thickness/2+1) / scale)
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
        updateSelection
          .exit().remove(); */
    };

    var onColorChange = function() {
        d3.select('#first_line').attr('stroke', first_color);
        d3.select('#second_line').attr('stroke', second_color);
    };

    var normalize_pts = function () {
        var centroid = calc_centroid(pts);
        for (var i = 0; i < pts.length; i++) {
            pts[i] = pts[i].sub(centroid);
        }

        var avg = avg_R(pts);
        var factor = 0.5 / avg_R(pts);
        for (var i = 0; i < pts.length; i++) {
            pts[i].scale(factor);
        }
    };

    var go = function (method) {
        var method_fn;
        if (method === "Smooth") {
            method_fn = smooth;
        } else if (method === "TSP") {
            method_fn = tsp;
        } else if (method === "Animate") {
            method_fn = animate;
        }

        if (!timer) {
            d3.select("#" + method).property('value', 'Stop');
            method_fn();
        } else {
            clearTimeout(timer);
            timer = null;
            d3.select("#" + method).property('value', method);
        }
    };

    var copy_pts = function (dest) {
        var result = [];
        for (var i = 0; i < pts.length; i++) {
            result.push(new DMSLib.Point2D(pts[i]));
        }
        return result;
    };

    var movement = function () {
        result = 0;
        for (var i = 0; i < pts.length; i++) {
            result += pts[i].sub(saved_pts[i]).R();
        }
        return result / pts.length;
    };


    var is_valid_new_point = function (new_pt, idx) {
        var prev = (idx - 1 + pts.length) % pts.length;
        var next = (idx + 1) % pts.length;

        tolerance = Math.min(pts[prev].sub(pts[idx]).R(),
                pts[idx].sub(pts[next]).R(),
                pts[prev].sub(pts[next]).R() * 0.5);

        for (var i = 0; i < pts.length; i++) {
            if (i === idx || i === prev || i === next) {
                continue;
            }
            if (pts[i].sub(new_pt).R() < tolerance) {
                return false;
            }
        }
        return true;
    };

    var is_convex = function () {
        var is_clockwise = pts[pts.length - 1].y * (pts[0].x - pts[pts.length - 1].x) >
                pts[pts.length - 1].x * (pts[0].y - pts[pts.length - 1].y);

        for (var idx = 0; idx < pts.length - 1; idx++) {
            var test = pts[idx].y * (pts[idx + 1].x - pts[idx].x) >
                    pts[idx].x * (pts[idx + 1].y - pts[idx].y);
            if (test != is_clockwise) {
                return false;
            }
        }

        return true;
    };

    var smooth = function(max_mvmt = 0) {
        // if max_mvt = 0, it's first frame: start animation 
        if (max_mvmt === 0) {
            animation2 = animation1;
            animation1 = [];
            var frame = copy_pts();
            animation1.push(frame);
        }

        saved_pts = copy_pts();
        var mvmt = 0;

        for (var num_iter = 0; num_iter < 2000; num_iter++) {
            var new_pts = [];
            for (var idx = 0; idx < pts.length; idx++) {
                var prev = (idx - 1 + pts.length) % pts.length;
                var next = (idx + 1) % pts.length;

                var angle = DMSLib.Point2D.angle(pts[prev], pts[idx], pts[next]);
                var factor = angle / DMSLib.QUARTERTAU;
                var new_pt = pts[idx].mul(factor)
                        .add(pts[prev])
                        .add(pts[next])
                        .div(2 + factor);

                if (is_valid_new_point(new_pt, idx)) {
                    new_pts[idx] = new_pt;
                } else {
                    new_pts[idx] = pts[idx];
                }
            }
            pts = new_pts;
            normalize_pts();

            mvmt = movement();
            if(mvmt >= max_mvmt) { break; }
        }

        // if this is first time through, we use this amount of movement as the step amount.
        if (max_mvmt === 0) {max_mvmt = mvmt;}

        var frame = copy_pts();
        animation1.push(frame);

        updateLine();

        if (mvmt < max_mvmt) {
            timer = null;
            d3.select('#Smooth').property('value', 'Smooth');
        } else {
            timer = setTimeout(function() {smooth(max_mvmt); }, 21);
        }
    };

    var tsp = function () {
        var changed = false;

        for (var a = 0; a < pts.length; a++) {
            for (var b = a + 2; b < pts.length; b++) {
                var anext = (a + 1) % pts.length;
                var bnext = (b + 1) % pts.length;

                var atoanext = pts[anext].sub(pts[a]).R();
                var btobnext = pts[bnext].sub(pts[b]).R();
                var atob = pts[b].sub(pts[a]).R();
                var anexttobnext = pts[bnext].sub(pts[anext]).R();

                if (atob + anexttobnext < atoanext + btobnext) {
                    // swap [anext ... b]
                    for (var idx = 0; anext + idx < b - idx; idx++) {
                        var from = (anext + idx) % pts.length;
                        var to = (b - idx) % pts.length;
                        var tmp = new DMSLib.Point2D(pts[from]);
                        pts[from] = new DMSLib.Point2D(pts[to]);
                        pts[to] = new DMSLib.Point2D(tmp);
                    }
                    changed = true;
                }
            }
        }

        updateLine();

        if (!changed) {
            timer = null;
            d3.select('#TSP').property('value', 'TSP');
        } else {
            timer = setTimeout(function() {tsp(); }, 21);
        }
    };

    var animate = function(frame = 0) {
        if(frame < animation1.length + animation2.length) {
            if(frame < animation1.length) {
                pts = animation1[frame]; 
            } else {
                pts = animation2[animation2.length + animation1.length - frame - 1]
            }
            updateLine(frame===0 ? 0 : 100);
            timer = setTimeout(function() {animate(frame+1); }, 100);
        } else {
            timer = null;
            d3.select('#Animate').property('value', 'Animate');
        }
    }

    /////////////////////////// data
    var house_pts = [ {x:10,y:1}, {x:9,y:2}, {x:11,y:2}, {x:8,y:3}, {x:12,y:3}, {x:7,y:4}, {x:13,y:4}, {x:6,y:4.95}, {x:7,y:5}, {x:13,y:5}, {x:14,y:4.95}, {x:7,y:6}, {x:13,y:6},
                      {x:7,y:7}, {x:13,y:7}, {x:7,y:8}, {x:13,y:8}, {x:7,y:9}, {x:13,y:9}, {x:7,y:10}, {x:13,y:10}, {x:7,y:11}, {x:13,y:11}, {x:13,y:12}, {x:13,y:13},
                      {x:6,y:12}, {x:7,y:12}, {x:5,y:13}, {x:6,y:13},
                      {x:0,y:14}, {x:1,y:14}, {x:2,y:14}, {x:3,y:14}, {x:4,y:14}, {x:5,y:14}, {x:13,y:14}, {x:14,y:14}, {x:15,y:14}, {x:16,y:14}, {x:17,y:14}, {x:18,y:14}, {x:19,y:14}, {x:20,y:14},
                      {x:0,y:16}, {x:2,y:16}, {x:4,y:16}, {x:6,y:16}, {x:8,y:16}, {x:10,y:16}, {x:14,y:16}, {x:16,y:16}, {x:18,y:16}, {x:20,y:16} ];

    // kick it off!
    var pts = get_random_pts(),
        saved_pts = copy_pts(),
        animation1 = [],
        animation2 = [];

    normalize_pts();
    updateLine();


</script>
