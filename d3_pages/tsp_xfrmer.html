<html>
<head>
    <script type='text/javascript' src='./d3.v3.min.js'></script>
    <script type='text/javascript' src='./d3-voronoi.v1.min.js'></script>
    <script type='text/javascript' src='./dmslib_core.js'></script>
    <script type='text/javascript' src='./dmslib_point2d.js'></script>
    <script type='text/javascript' src='./tsp_tour_generation.js'></script>
    <script type='text/javascript' src='./tsp_tour_utilities.js'></script>
</head>
<body>
    <div id='controls'>
        <label for='first_color'>1st Colour:</label> <input id='first_color' type='text' value='red' onchange='first_color=this.value;onColorChange();'>
        <label for='first_color_segments'>#:</label> <input id='first_color_segments' type='number' min='0' value='0' onchange='first_color_segments=this.value;updateLine();'>
        <label for='second_color'>2nd Colour:</label> <input id='second_color' type='text' value='black' onchange='second_color=this.value;onColorChange();'>
        <button id='do_dots' onclick='do_dots=!do_dots;updateLine();'>toggle dots</button><br>
        <button onclick='get_tour("random");'>random</button>
        <button onclick='get_tour("house");'>house</button>
        <button onclick='get_tour("circle");'>circle</button>
        <button onclick='get_tour("spiral");'>spiral</button><br><br>

        <input type='file' onchange='onTargetSelected(event)' value='chose target'/>
        <label for='requested_size'>Pts:</label> <input id='requested_size' type='number' value=1024 onchange='requested_size=this.value;'>
        <button onclick='get_tour("target");'>target</button>
        <input type='button' id='Stipple' onclick='go("Stipple")' value='Stipple'/>
        <input type='button' id='TSP' onclick='go("TSP")' value='TSP'/>
        <input type='button' id='Smooth' onclick='go("Smooth")' value='Smooth'/> <br><br>

        <label for='sa_temp'>SA temp.:</label> <input id='sa_temp' type='number' min='0' max='10' value='3' onchange='sa_temp=this.value;'/>
        <input type='button' id='OptimizeAnimation' onclick='go("OptimizeAnimation")' value='OptimizeAnimation'/>
        <button id='reduce_stepsize' onclick='if(step_size>1) {step_size>>=1;}'>step&gt;&gt;</button>
        <label for='pps'>Pixels per second:</label> <input id='pps' type='number' min='1' max=1000 value=100 onchange='pps=this.value;'>
        <input type='button' id='Animate' onclick='go("Animate")' value='Animate'/>
        <input type='button' id='TakeTour' onclick='go("TakeTour")' value='Take Tour'/><br><br>
    </div>

    <div id='output'></div>

    <div id='target' hidden>
        <img id='target_picture' style='border-width:1px' src=""/>
    </div>
</body>
</html>


<script>
    var size = new DMSLib.Point2D(1280, 720),
        first_color_segments = 0,
        first_color = 'red',
        second_color = 'black',
        line_thickness = 4,
        requested_size = 1024,
        timer,
        do_dots = false,
        sa_temp = 3,
        pps = 100,
        step_size=1,
        target = {width:1280, height:720, pixel: function() {return 0;} };



    ///////////////////// D3 focused display routines.
    var svg = d3.select('#output').append('svg')
            .attr('width', size.x)
            .attr('height', size.y)
            .attr("style", "outline: thin solid red;");

    var line_space = svg.append('g');

    var first_line = line_space.append('path')
            .attr('id', 'first_line')
            .attr('stroke', first_color)
            .attr('stroke-width', line_thickness)
            .attr('fill', 'none');
    var second_line = line_space.append('path')
            .attr('id', 'second_line')
            .attr('stroke', second_color)
            .attr('stroke-width', line_thickness)
            .attr('fill', 'none');

    var lineFunction = d3.svg.line()
            .x(function(d) { return d.x;})
            .y(function(d) { return d.y;})
            .interpolate('linear');
            // .interpolate('cardinal');

    var updateLine = function(frame_time, easing) {
        var first_line_pts = tour.slice(0,first_color_segments)
                                 .concat(tour[first_color_segments%tour.length]);
        var second_line_pts = tour.slice(first_color_segments,tour.length)
                                  .concat(tour[0]);

        if (frame_time===undefined) {
            first_line.attr('d', lineFunction(first_line_pts));
            second_line.attr('d', lineFunction(second_line_pts));
        } else {
            if(easing===undefined) {easing = 'linear';}
            first_line
                    .transition()
                    .duration(frame_time)
                    .ease(easing)
                    .attr('d', lineFunction(first_line_pts));
            second_line
                    .transition()
                    .duration(frame_time)
                    .ease(easing)
                    .attr('d', lineFunction(second_line_pts));
        }

        dotSelection = line_space.selectAll('.dot').data(tour);
        if(do_dots) {
            dotSelection
                .attr('r', line_thickness/2+1 )
                .attr('cx', function(d) { return d.x; })
                .attr('cy', function(d) { return d.y; });
            dotSelection
              .enter().append('circle')
                .attr('class', 'dot')
                .attr('r', line_thickness/2+1 )
                .attr('cx', function(d) { return d.x; })
                .attr('cy', function(d) { return d.y; });
            dotSelection
              .exit().remove();
        } else {
            dotSelection.remove();
        }
    };

    var onColorChange = function() {
        d3.select('#first_line').attr('stroke', first_color);
        d3.select('#second_line').attr('stroke', second_color);
    };


    ////////////////////////////////// Launching framework
    var go = function (method) {
        var method_fns = { 'Smooth' : smooth,
                           'Stipple' : stipple,
                           'TSP' : tsp,
                           'Animate' : animate,
                           'TakeTour' : take_tour,
                           'OptimizeAnimation' : optimize_animation };
        var method_fn = method_fns[method];

        if (!timer) {
            d3.select('#' + method).property('value', 'Stop');
            method_fn();
        } else {
            clearTimeout(timer);
            timer = null;
            d3.select('#' + method).property('value', method);
        }
    };

    var get_tour = function(method) {
        var method_fns = {'circle' : get_circle_pts,
                          'spiral' : get_spiral_pts,
                          'house' : get_house_pts,
                          'target': get_target_pts,
                          'random' : get_random_pts};
        var method_fn = method_fns[method];

        tour = method_fn(requested_size, target);
        updateLine();
    };


    var is_valid_new_point = function(pts, new_pt, idx, check_proximity) {
        var a1 = pts[(idx - step_size + pts.length) % pts.length];
        var old_a2 = pts[idx];
        var new_a2 = new_pt;
        var a3 = pts[(idx + step_size) % pts.length];


        var tolerance = Math.min(a1.sub(a3).R()) * 0.2;

        for (var i = 0; i < pts.length; i+=step_size) {
            var b1 = pts[i];
            var b2 = pts[(i+step_size)%pts.length];

            if(check_proximity === true) {
                if(b1 !== a1 && b1 !== old_a2 && b1 !== a3) {
                    if (b1.sub(new_a2).R() < tolerance) {
                        return false;
                    }
                }
            }

            // edge intersection
            if (b1 !== a1 && b1 !== old_a2) {
                if (edge_intersects_edge(a1, new_a2, b1, b2) || edge_intersects_edge(new_a2, a3, b1, b2)) {
                    return false;
                }
            }
        }
        return true;
    };


    //////////////////////////////// Workhorse routines.
    var smooth = function(max_mvmt) {
        var pointspread = get_pointspread(tour);

        // if max_mvt = undefined, it's first frame: start animation
        if (max_mvmt === undefined) {
            max_mvmt = 0;

            step_size=1;

            animation2 = animation;
            animation = [];
            var frame = copy_pts(tour);
            animation.push(frame);
        }

        var saved_tour = copy_pts(tour);

        if( tour.length/step_size > 360 &&
            (tour.length % (step_size*2) === 0) &&
            avg_bend(tour, step_size) < 0.8) { // ~5 degrees
            step_size *= 2;
        }

        var num_iter, idx, prev, next;
        for (num_iter = 0; num_iter < 2000; num_iter++) {
            var new_tour = [];
            for (idx = 0; idx < tour.length; idx+=step_size) {
                prev = (idx - step_size + tour.length) % tour.length;
                next = (idx + step_size) % tour.length;

                var new_pt = tour[idx].add(tour[prev]).add(tour[next]).div(3);

                if (is_valid_new_point(tour, new_pt, idx, true)) {
                    new_tour[idx] = new_pt;
                } else {
                    new_tour[idx] = tour[idx];
                }
            }
            fill_in_tour(new_tour, step_size);
            tour = new_tour;
            set_pointspread(tour, pointspread);

            var mvmt = movement(tour, saved_tour);
            if (max_mvmt === undefined || max_mvmt === 0) { max_mvmt = mvmt; }
            if(mvmt >= max_mvmt) { break; }
        }

        // if this is first time through, we use this amount of movement as the step amount.
        animation.push(copy_pts(tour));

        updateLine();

        if (mvmt < max_mvmt) {
            timer = null;
            d3.select('#Smooth').property('value', 'Smooth');
        } else {
            timer = setTimeout(function() {smooth(max_mvmt); }, 21);
        }
    };

    var onTargetSelected = function(event) {
        // d3.select('#target_picture').attr('src', event.target.files[0].name);
        var img = document.getElementById('target_picture');

        var selectedFile = event.target.files[0];
        var reader = new FileReader();
        img.title = selectedFile.name;

        reader.onload = function(event) {
            img.onload = getTargetFromImage;
            img.src = event.target.result;
        };
        reader.readAsDataURL(selectedFile);
    };

    var getTargetFromImage = function() {
        var img = document.getElementById('target_picture');

        var c = document.createElement('canvas');
        c.width = img.width;
        c.height = img.height;

        var ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0);

        target = ctx.getImageData(0, 0, c.width, c.height);
        target.pixel = function(x,y) { x=Math.floor(x); y=Math.floor(y); return this.data[y*this.width*4+x*4]; };
    };

    var stipple = function (iter) {
        var voronoi = d3.voronoi()
                .x(function(d) {return d.x;})
                .y(function(d) {return d.y;})
                .extent([[-1, -1], [target.width, target.height]]);
        var diagram = voronoi(tour);

        // initialize accumulator variables
        var newpos = [];
        var sumofweights = [];
        var i;
        for(i=0; i<tour.length; i++) {
            newpos.push(new DMSLib.Point2D());
            sumofweights.push(0);
        }

        // add weighted images pixels to nearest cities
        for(var x=0; x<target.width; x++) {
            for (var y = 0; y < target.height; y++) {
                var idx = diagram.find(x,y).index;
                var weight = 255-target.pixel(x,y);
                if(weight) {
                    newpos[idx] = newpos[idx].add(new DMSLib.Point2D(x,y).mul(weight));
                    sumofweights[idx] += weight;
                }
            }
        }

        // calculate weighted average and show
        for(i=0; i<tour.length; i++) {
            if(sumofweights[i]) {
                tour[i] = newpos[i].div(sumofweights[i]);
            }
        }
        updateLine();

        if(iter=== undefined) iter=20;
        if(iter!=0) {
            timer = setTimeout(function() {stipple(iter-1); }, 21);
        } else {
            timer = null;
            d3.select('#Stipple').property('value', 'Stipple');
        }
    };

    var tsp = function () {
        var changed = false;

        var a1, b1, a2, b2,
            a1toa2, b1tob2, a1tob1, a2tob2;
        for (a1 = 0; a1 < tour.length; a1++) {
            for (b1 = a1 + 2; b1 < tour.length; b1++) {
                a2 = (a1 + 1) % tour.length;
                b2 = (b1 + 1) % tour.length;

                a1toa2 = tour[a2].sub(tour[a1]).R();
                b1tob2 = tour[b2].sub(tour[b1]).R();
                a1tob1 = tour[b1].sub(tour[a1]).R();
                a2tob2 = tour[b2].sub(tour[a2]).R();

                if (a1tob1 + a2tob2 < a1toa2 + b1tob2) {
                    // swap [a2 ... b1]
                    var idx, from, to, tmp;
                    for (idx = 0; a2 + idx < b1 - idx; idx++) {
                        from = (a2 + idx) % tour.length;
                        to = (b1 - idx) % tour.length;
                        tmp = new DMSLib.Point2D(tour[from]);
                        tour[from] = new DMSLib.Point2D(tour[to]);
                        tour[to] = new DMSLib.Point2D(tmp);
                    }
                    changed = true;
                }
            }
        }

        if (!changed) {
            timer = null;
            d3.select('#TSP').property('value', 'TSP');
            if(animation.length) { tour = match_other(tour, animation[0]);}
            updateLine();
        } else {
            updateLine();
            timer = setTimeout(function() {tsp(); }, 21);
        }
    };


    var take_tour = function() {
        first_color_segments++;
        d3.select('#first_color_segments').property('value', first_color_segments);
        updateLine();

        if(first_color_segments < tour.length) {
            var frame_time = tour[first_color_segments].sub(tour[first_color_segments-1]).R() / pps * 1000;
            timer = setTimeout(function() {take_tour(); }, frame_time);
        } else {
            timer = null;
            d3.select('#TakeTour').property('value', 'Take Tour');
        }
    };

    var animate = function(frame) {
        var frame_time, delay, easing;

        if(frame === undefined) {
            frame = 0;
            frame_time = undefined;
            delay = 1000;
        } else if (frame === animation.length) {
            timer = null;
            d3.select('#Animate').property('value', 'Animate');
            return;
        } else {
            frame_time = movement(animation[frame], animation[frame-1]) / pps * 1000;
            delay = frame_time;
            easing = 'linear';
        }

        if(frame===1) {
            easing = 'cubic-in';
            frame_time *= 3;
            delay *= 3;
        } else if(frame === animation.length-1) {
            easing = 'cubic-out';
            frame_time *= 3;
            delay *= 3;
        }

        tour = animation[frame];
        updateLine(frame_time, easing);
        timer = setTimeout(function () { animate(frame + 1); }, delay);
    };

    var optimize_animation = function() {
        if(animation2.length) {
            animation = animation.concat(animation2.reverse());
            animation2 = [];
        }

        for(var f = 1; f < animation.length-1; f++) {
            var new_frame = [];
            var avg_edge_size = avg_edge(tour);
            for(var p = 0; p < animation[f].length; p+=step_size) {

                var prev = (p + animation[f].length - step_size) % animation[f].length;
                var next = (p + step_size) % animation[f].length;

                var newpt = animation[f][p]
                        .add(animation[f+1][p])
                        .add(animation[f-1][p])
                        .add(animation[f][prev].mul(0.05))
                        .add(animation[f][next].mul(0.05))
                        .div(3.1)
                        .add(DMSLib.Point2D.fromPolar(Math.random() * avg_edge_size * (sa_temp / 10),
                                                      Math.random() * DMSLib.TAU));

                if( is_valid_new_point(animation[f], newpt, p)) {
                    new_frame[p] = newpt;
                } else {
                    new_frame[p] = animation[f][p];
                }
            }
            fill_in_tour(new_frame,step_size);
            animation[f] = new_frame;
        }

        tour = animation[Math.floor(animation.length/2)];
        updateLine();

        timer = setTimeout(function() {optimize_animation();}, 11);
    };

    /////////////////////////////// kick it off!
    var tour = [],
        animation = [],
        animation2 = [];

    get_tour('random');

    // TODO - move animation, stippling to new file
    // TODO - 3d version: on a sphere.
    // TODO - read / write routes from/to file system

</script>
