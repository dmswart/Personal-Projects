<html>
<head>
    <script src='./dmslib_core.js'></script>
    <script src='./dmslib_point2d.js'></script>
    <script src='./tsp_tour_generation.js'></script>
    <script src='./tsp_tour_utilities.js'></script>
    <script src='http://d3js.org/d3.v3.min.js'></script>
</head>
<body>
    <div id='controls'>
        <label for='first_color'>1st Colour:</label> <input id='first_color' type='text' value='red' onchange='first_color=this.value;onColorChange();'>
        <label for='first_color_percentage'>%:</label> <input id='first_color_percentage' type='number' min='0' max='100' value='0' onchange='first_color_percentage=this.value;updateLine();'>
        <label for='second_color'>2nd Colour:</label> <input id='second_color' type='text' value='black' onchange='second_color=this.value;onColorChange();'><br>
        <label for='requested_size'>Pts:</label> <input id='requested_size' type='number' value=200 onchange='requested_size=this.value;'>
        <label for='fps'>Frames per second:</label> <input id='fps' type='number' min='1' max=1000 value=16 onchange='fps=this.value;'> <br>
        <button onclick='get_tour("random");'>random</button>
        <button onclick='get_tour("house");'>house</button>
        <button onclick='get_tour("circle");'>circle</button>
        <button onclick='get_tour("spiral");'>spiral</button><br><br>

        <input type='button' id='TSP' onclick='go("TSP")' value='TSP'/>
        <input type='button' id='Smooth' onclick='go("Smooth")' value='Smooth'/>
        <input type='button' id='Animate' onclick='go("Animate")' value='Animate'/> <br>
    </div>

    <div id='output'></div>
</body>
</html>


<script>
    var scale = 350,
        size = new DMSLib.Point2D(2*scale+580, 2*scale+20),
        center = size.div(2),
        first_color_percentage = 0.0,
        first_color = 'red',
        second_color = 'black',
        line_thickness = 4,
        requested_size = 200,
        timer,
        fps = 30;


    ///////////////////// D3 focused display routines.
    var svg = d3.select('#output').append('svg')
            .attr('width', size.x)
            .attr('height', size.y);

    var line_space = svg.append('g')
            .attr('transform', 'translate('+center.x+','+center.y+') scale('+scale+')');

    first_line = line_space.append('path')
            .attr('id', 'first_line')
            .attr('stroke', first_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');
    second_line = line_space.append('path')
            .attr('id', 'second_line')
            .attr('stroke', second_color)
            .attr('stroke-width', line_thickness/scale)
            .attr('fill', 'none');

    var lineFunction = d3.svg.line()
            .x(function(d) { return d.x;})
            .y(function(d) { return d.y;})
            .interpolate('linear');

    var updateLine = function(frame_time) {
        // split first, second
        var split = Math.floor(tour.length * first_color_percentage / 100.0);
        var second_line_pts = tour.slice(split,tour.length);
        second_line_pts.push(tour[0]);

        if (frame_time===undefined) {
            first_line.attr('d', lineFunction(tour.slice(0,split+1)));
            second_line.attr('d', lineFunction(second_line_pts));
        } else {
            first_line
                    .transition()
                    .duration(frame_time)
                    .attr('d', lineFunction(tour.slice(0,split+1)));
            second_line
                    .transition()
                    .duration(frame_time)
                    .attr('d', lineFunction(second_line_pts));
        }
    };

    var onColorChange = function() {
        d3.select('#first_line').attr('stroke', first_color);
        d3.select('#second_line').attr('stroke', second_color);
    };


    ////////////////////////////////// Launching framework
    var go = function (method) {
        var method_fns = { "Smooth" : smooth, "TSP" : tsp, "Animate" : animate};
        var method_fn = method_fns[method];

        if (!timer) {
            d3.select('#' + method).property('value', 'Stop');
            method_fn();
        } else {
            clearTimeout(timer);
            timer = null;
            d3.select('#' + method).property('value', method);
        }
    };

    var get_tour = function(method) {
        var method_fns = {'circle' : get_circle_pts, 'spiral' : get_spiral_pts, 'house' : get_house_pts, 'random' : get_random_pts};
        var method_fn = method_fns[method];

        tour = method_fn(requested_size);
        normalize(tour);
        updateLine();
    };

    var is_valid_new_point = function(pts, new_pt, idx) {
        var prev = (idx - 1 + pts.length) % pts.length;
        var next = (idx + 1) % pts.length;

        tolerance = Math.min(pts[prev].sub(pts[idx]).R(),
                pts[idx].sub(pts[next]).R(),
                pts[prev].sub(pts[next]).R() * 0.5);

        for (var i = 0; i < pts.length; i++) {
            if (i === idx || i === prev || i === next) {
                continue;
            }
            if (pts[i].sub(new_pt).R() < tolerance) {
                return false;
            }
        }
        return true;
    };

    var smooth = function(max_mvmt) {
        var mvmt = 0;

        // if max_mvt = undefined, it's first frame: start animation
        if (max_mvmt === undefined) {
            max_mvmt = 0;

            animation2 = animation1;
            animation1 = [];
            var frame = copy_pts(tour);
            animation1.push(frame);
        }

        var saved_tour = copy_pts(tour);

        var num_iter, idx, prev, next;
        for (num_iter = 0; num_iter < 2000; num_iter++) {
            new_tour = [];
            for (idx = 0; idx < tour.length; idx++) {
                prev = (idx - 1 + tour.length) % tour.length;
                next = (idx + 1) % tour.length;

                var angle, factor, new_pt;
                angle = DMSLib.Point2D.angle(tour[prev], tour[idx], tour[next]);
                factor = angle / DMSLib.QUARTERTAU;
                new_pt = tour[idx].mul(factor)
                        .add(tour[prev])
                        .add(tour[next])
                        .div(2 + factor);

                if (is_valid_new_point(tour, new_pt, idx)) {
                    new_tour[idx] = new_pt;
                } else {
                    new_tour[idx] = tour[idx];
                }
            }
            tour = new_tour;
            normalize(tour);

            mvmt = movement(tour, saved_tour);
            if(mvmt >= max_mvmt) { break; }
        }

        // if this is first time through, we use this amount of movement as the step amount.
        if (max_mvmt === 0) {max_mvmt = mvmt;}

        animation1.push(copy_pts(tour));

        updateLine();

        if (mvmt < max_mvmt) {
            timer = null;
            d3.select('#Smooth').property('value', 'Smooth');
        } else {
            timer = setTimeout(function() {smooth(max_mvmt); }, 21);
        }
    };

    var tsp = function () {
        var changed = false;

        var a, b, anext, bnext;
        var atoanext, btobnext, atob, anexttobnext;
        for (a = 0; a < tour.length; a++) {
            for (b = a + 2; b < tour.length; b++) {
                anext = (a + 1) % tour.length;
                bnext = (b + 1) % tour.length;

                atoanext = tour[anext].sub(tour[a]).R();
                btobnext = tour[bnext].sub(tour[b]).R();
                atob = tour[b].sub(tour[a]).R();
                anexttobnext = tour[bnext].sub(tour[anext]).R();

                if (atob + anexttobnext < atoanext + btobnext) {
                    // swap [anext ... b]
                    var idx, from, to, tmp;
                    for (idx = 0; anext + idx < b - idx; idx++) {
                        from = (anext + idx) % tour.length;
                        to = (b - idx) % tour.length;
                        tmp = new DMSLib.Point2D(tour[from]);
                        tour[from] = new DMSLib.Point2D(tour[to]);
                        tour[to] = new DMSLib.Point2D(tmp);
                    }
                    changed = true;
                }
            }
        }

        if (!changed) {
            timer = null;
            d3.select('#TSP').property('value', 'TSP');
            if(animation1.length) { tour = match_other(tour, animation1[0]);}
            updateLine();
        } else {
            updateLine();
            timer = setTimeout(function() {tsp(); }, 21);
        }
    };


    var animate = function(frame) {
        if(frame === undefined) { frame = 0; }
        if(frame < animation1.length + animation2.length) {
            if(frame < animation1.length) {
                tour = animation1[frame];
            } else {
                tour = animation2[animation2.length + animation1.length - frame - 1]
            }
            updateLine(frame===0 ? 0 : 1000/fps);
            timer = setTimeout(function() {animate(frame+1); }, 1000/fps);
        } else {
            timer = null;
            d3.select('#Animate').property('value', 'Animate');
        }
    };

    /////////////////////////////// kick it off!
    var tour = [],
        animation1 = [],
        animation2 = [];

    get_tour('random');


    // TODO - make a tour class, an animation class
    // TODO - 3d version: on a sphere.
    // TODO - read / write routes from file system
    // TODO - write animation to file system
    // TODO - figure out why frame_time isn't smooth for slow transitions.


</script>
