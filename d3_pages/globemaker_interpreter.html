<html>
<head>
<script src='http://d3js.org/d3.v3.min.js'></script>
<script src='./dmslib_core.js'></script>
<script src='./dmslib_point2d.js'></script>
<script src='./dmslib_point3d.js'></script>
<script src='./dmslib_xfrm.js'></script>
<script src='./globemaker_segment.js'></script>
<script src='./globemaker_relative_position.js'></script>
<script src='./globemaker_skeleton.js'></script>
<script src='./globemaker_parse.js'></script>
</head>

<body>
<div style='width: 100%; overflow: hidden;'>
    <div id='output' style='width: 500px; float: left;'></div>
    <div style='margin-left: 520px;'> 
        <textarea id='input' type='text' cols=40 rows=32 style='overflow:scroll' onchange='newSkeleton(this.value);'>l 0</textarea>
    </div>
</div>
</body>

</html>

<script>
    const size = 500;
    let __scale = 50.0;
    let svg;

    function setupPreview() {
        svg = d3.select('#output').append('svg')
            .attr('width', size)
            .attr('height',size)
        svg.append('rect')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('stroke', 'gray')
            .attr('stroke-width', 1)
            .attr('fill', 'silver');
        svg.append('g').attr('id', 'lines')
            .attr('transform', 'translate(' + size/2 + ',' + size/2 + ')')
            .attr('stroke', 'blue')
            .attr('stroke-width', 2)
            .attr('fill', 'none');
        svg.append('g').attr('id', 'moves')
            .attr('transform', 'translate(' + size/2 + ',' + size/2 + ')')
            .attr('stroke', 'gray')
            .attr('stroke-width', 1)
            .attr('fill', 'none');
        svg.append('g').attr('id', 'move_on_plane')
            .attr('transform', 'translate(' + size/2 + ',' + size/2 + ')')
            .attr('stroke', 'gray')
            .attr('stroke-width', 1)
            .attr('fill', 'none');
        svg.append('g').attr('id', 'grid')
            .attr('transform', 'translate(' + size/2 + ',' + size/2 + ')')
            .attr('stroke', 'none');
    }

    function updateLines(skel) {
        let selection = svg.select('#lines').selectAll('path')
            .data(skel.list('line'), d => d.id);
        selection.enter().append('path')
            .attr('d', d => 'M' + d.x1 + ',' + d.y1 + 'L' + d.x2 + ',' + d.y2);
        selection.exit().remove();
        selection = svg.select('#lines').selectAll('circle')
            .data(skel.list('line'), d => d.id);
        selection.enter().append('circle')
            .attr('r', 2)
            .attr('cx', d => d.x2)
            .attr('cy', d => d.y2);
        selection.exit().remove();
    }

    function updateMoves(skel) {
        // moves on plane
        let selection = svg.select('#move_on_plane').selectAll('path')
            .data(skel.list('move_on_plane'), d => d.id);
        selection.enter().append('path')
            .attr('d', d => 'M' + d.x1 + ',' + d.y1 + 'L' + d.x2 + ',' + d.y2)
            .attr('stroke-dasharray', '3,3');
        selection.exit().remove();
        selection = svg.select('#move_on_plane').selectAll('circle')
            .data(skel.list('move_on_plane'), d => d.id);
        selection.enter().append('circle')
            .attr('r', 1)
            .attr('fill', 'gray')
            .attr('cx', d => d.x2)
            .attr('cy', d => d.y2);
        selection.exit().remove();

        // normal moves
        selection = svg.select('#moves').selectAll('path')
            .data(skel.list('move'), d => d.id);
        selection.enter().append('path')
            .attr('d', d => 'M' + d.x1 + ',' + d.y1 + 'L' + d.x2 + ',' + d.y2);
        selection.exit().remove();
        selection = svg.select('#moves').selectAll('circle')
            .data(skel.list('move'), d => d.id);
        selection.enter().append('circle')
            .attr('r', 1)
            .attr('fill', 'gray')
            .attr('cx', d => d.x2)
            .attr('cy', d => d.y2);
        selection.exit().remove();
    }

    function evaluateCoordinate(skel, x, y) {
        const P = new DMSLib.Point2D( x / __scale, y / __scale);

        //given P, find nearest relative position to segment S on plane
        const rpS = skel.relativePositiontoNearestSegmentOnPlane(P);

        //determine corresponding point Q on sphere.
        const Q = rpS.pointOnSphere();

        //find if nearest segment on sphere to Q exists.
        if( skel.nearerSegmentOnSphereExists( Q, rpS.distance * rpS.seg.strength ) ) {
            return false; // empty
        } else {
            return true;  // m_Source.GetSpherePixel( Q ) for color from source;
        }
    }

    function updateGrid(skel) {
        const density = 30
        const gridData = [];
        for (let i = 0; i < density; i++) {
            for (let j = 0; j < density; j++) {
                let x = (i -(density/2)+ 0.5) * (size/density);
                let y = (j -(density/2)+ 0.5) * (size/density);
                gridData.push({x: x, y: y, val: this.evaluateCoordinate(skel, x, y), id: i * density + j});
            }
        }
        let selection = svg.select('#grid').selectAll('circle')
            .data(gridData, d => d.id);
        selection.enter().append('circle')
            .attr('r', 3)
            .attr('cx', d => d.x)
            .attr('cy', d => d.y)
            .attr('fill', d => (d.val ? 'black' : 'white'));
        selection.exit().remove();
        selection
            .attr('fill', d => (d.val ? 'black' : 'white'));
    }

    function newSkeleton(skeleton_def) {
        let skel = new Skeleton(__scale);
        if(parseGlobemaker(skeleton_def, skel)) {
            // input text box successfully parsed: white background
            d3.select('#input').attr('style', 'background-color:white');

            updateLines(skel);
            updateMoves(skel);
            updateGrid(skel);
        } else {
            // input text box unsuccessful: pink background
            d3.select('#input').attr('style', 'background-color:pink');
        }
    }

    setupPreview();
</script>
